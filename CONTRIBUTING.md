# Contributing to Obby

Thank you for considering contributing to Obby\! This document provides guidelines and instructions for contributing to this project.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Setup](#development-setup)
- [Development Workflow](#development-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [Testing Requirements](#testing-requirements)
- [Pull Request Process](#pull-request-process)
- [Issue Reporting](#issue-reporting)
- [Feature Requests](#feature-requests)
- [Community](#community)

## Code of Conduct

By participating in this project, you agree to abide by our [Code of Conduct](CODE_OF_CONDUCT.md). Please read it before contributing.

## Getting Started

### Prerequisites

- **Android Studio** Hedgehog (2023.1.1) or newer
- **JDK** 11 or newer
- **Kotlin** 2.0.21+
- **Android SDK** 33+ (compileSdk 36)
- **Git** for version control

### Fork and Clone

1. **Fork the repository** on GitHub
2. **Clone your fork:**
   ```bash
   git clone https://github.com/YOUR_USERNAME/obby.git
   cd obby
   ```
3. **Add upstream remote:**
   ```bash
   git remote add upstream https://github.com/ORIGINAL_OWNER/obby.git
   ```

## Development Setup

### Initial Setup

1. **Open the project in Android Studio:**
   - File → Open → Select the cloned directory

2. **Sync Gradle:**
   - The IDE will automatically prompt to sync
   - Or manually: File → Sync Project with Gradle Files

3. **Run the app:**
   - Connect a device or start an emulator
   - Click Run (▶️) or press `Shift+F10`

### Environment Configuration

- No API keys or environment variables are required
- All data is stored locally
- `local.properties` is auto-generated by Android Studio

### Troubleshooting Setup

If you encounter build issues:

```bash
# Clean project
./gradlew clean

# Rebuild
./gradlew build

# Or in Android Studio: Build → Clean Project → Rebuild Project
```

## Development Workflow

### Branch Strategy

We follow a **trunk-based development** model:

- **`main`** - production-ready code
- **feature branches** - short-lived branches for new features
- **bugfix branches** - for bug fixes

### Creating a Branch

```bash
# Update main
git checkout main
git pull upstream main

# Create feature branch
git checkout -b feature/your-feature-name

# Or for bug fixes
git checkout -b bugfix/issue-description
```

### Branch Naming Convention

- **Features:** `feature/short-description`
- **Bug fixes:** `bugfix/issue-number-description`
- **Refactoring:** `refactor/what-is-refactored`
- **Documentation:** `docs/what-is-documented`
- **Tests:** `test/what-is-tested`

### Commit Message Convention

We follow [Conventional Commits](https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types:**
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `style`: Code style changes (formatting, no logic change)
- `refactor`: Code refactoring
- `test`: Adding or updating tests
- `chore`: Build process or auxiliary tool changes
- `perf`: Performance improvements

**Examples:**
```bash
git commit -m "feat(editor): add markdown table insertion"
git commit -m "fix(database): resolve migration crash on upgrade"
git commit -m "docs(readme): update installation instructions"
git commit -m "test(viewmodel): add unit tests for NotesViewModel"
```

## Code Style Guidelines

### Kotlin Conventions

Follow [Kotlin Coding Conventions](https://kotlinlang.org/docs/coding-conventions.html).

#### Key Principles

1. **Naming:**
   - Classes: `PascalCase`
   - Functions/variables: `camelCase`
   - Constants: `UPPER_SNAKE_CASE`
   - Private properties: `_prefixedCamelCase` (for backing fields)

2. **Nullability:**
   - Prefer non-null types
   - Use `?.` and `?:` operators appropriately
   - Avoid `\!\!` unless absolutely certain

3. **Immutability:**
   - Prefer `val` over `var`
   - Use immutable collections (`List` over `MutableList`)
   - Use `copy()` for data classes

4. **Scope Functions:**
   - `let` - null checks and transformations
   - `apply` - object configuration
   - `run` - scoped operations
   - `also` - side effects
   - `with` - multiple calls on same object

#### Compose Guidelines

1. **Composable Naming:**
   - Start with capital letter (like classes)
   - Use descriptive names: `NoteListItem`, not `Item`

2. **State Management:**
   - Hoist state when possible
   - Use `remember` for local state
   - Use `ViewModel` for screen-level state

3. **Preview Annotations:**
   ```kotlin
   @Preview(showBackground = true)
   @Composable
   fun NoteListItemPreview() {
       ObbyTheme {
           NoteListItem(/* ... */)
       }
   }
   ```

4. **Modifiers:**
   - Pass `Modifier` as first optional parameter
   - Chain modifiers in logical order


#### ViewModel Patterns

```kotlin
class ExampleViewModel(
    private val repository: Repository
) : ViewModel() {
    
    // Private mutable state
    private val _uiState = MutableStateFlow(UiState())
    // Public immutable state
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()
    
    // Use viewModelScope for coroutines
    fun performAction() {
        viewModelScope.launch {
            try {
                repository.doSomething()
                _uiState.update { it.copy(success = true) }
            } catch (e: Exception) {
                Log.e(TAG, "Error performing action", e)
                _uiState.update { it.copy(error = e.message) }
            }
        }
    }
}
```

#### Repository Patterns

```kotlin
class ExampleRepository(
    private val dao: ExampleDao
) {
    // Return Flow for reactive data
    fun getItems(): Flow<List<Item>> = dao.getAllItems()
    
    // Suspend functions for one-shot operations
    suspend fun insertItem(item: Item): Long {
        return dao.insert(item)
    }
}
```

## Testing Requirements

### Test Coverage

- **Minimum coverage:** 70% for new code
- **ViewModels:** Must have unit tests
- **Repositories:** Must have unit tests
- **UI:** Compose tests for critical flows

### Test Structure

```
app/src/
  └── test/           # Unit tests (JVM)
  └── androidTest/    # Instrumentation tests (Android device)
```

### Writing Unit Tests

```kotlin
class NotesViewModelTest {
    
    @get:Rule
    val coroutineRule = MainCoroutineRule()
    
    private lateinit var viewModel: NotesViewModel
    private lateinit var repository: FakeNoteRepository
    
    @Before
    fun setup() {
        repository = FakeNoteRepository()
        viewModel = NotesViewModel(repository)
    }
    
    @Test
    fun `createNote should add note to repository`() = runTest {
        // Given
        val title = "Test Note"
        
        // When
        viewModel.createNote(title)
        
        // Then
        val notes = repository.getAllNotes().first()
        assertEquals(1, notes.size)
        assertEquals(title, notes[0].title)
    }
}
```

### Running Tests

```bash
# Run all unit tests
./gradlew test

# Run all instrumentation tests
./gradlew connectedAndroidTest

# Run tests for a specific module
./gradlew :app:test

# Generate coverage report
./gradlew jacocoTestReport
```

### Test Checklist

- [ ] Unit tests for new ViewModels
- [ ] Unit tests for new Repository methods
- [ ] Tests for edge cases (empty, null, error states)
- [ ] Compose tests for new UI components
- [ ] Tests pass locally before pushing

## Pull Request Process

### Before Creating a PR

1. **Ensure your branch is up to date:**
   ```bash
   git fetch upstream
   git rebase upstream/main
   ```

2. **Run all checks locally:**
   ```bash
   ./gradlew clean build test ktlintCheck detekt
   ```

3. **Test manually:**
   - Run the app on a device
   - Verify your changes work as expected
   - Test edge cases

### Creating a Pull Request

1. **Push your branch:**
   ```bash
   git push origin feature/your-feature-name
   ```

2. **Open PR on GitHub:**
   - Go to the repository on GitHub
   - Click "Compare & pull request"
   - Fill out the PR template

### PR Template

```markdown
## Description
Brief description of what this PR does.

## Type of Change
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update

## Related Issue
Fixes #(issue number)

## Screenshots (if applicable)
Add screenshots or GIFs demonstrating the change.

## Testing
- [ ] Unit tests pass locally
- [ ] Instrumentation tests pass (if applicable)
- [ ] Manual testing completed
- [ ] No new warnings or errors

## Checklist
- [ ] My code follows the style guidelines
- [ ] I have performed a self-review
- [ ] I have commented my code, particularly in hard-to-understand areas
- [ ] I have updated the documentation
- [ ] My changes generate no new warnings
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally
- [ ] Any dependent changes have been merged and published
```

## Thank You\!

Your contributions make Obby better for everyone. We appreciate your time and effort\! 🎉

